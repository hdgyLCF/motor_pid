
## PID 恒速控制 — 实现流程（基于当前工程）

下面文档反映当前代码库的实际实现细节，便于在 Proteus/vofa 仿真或代码审查时参考。

**入口（上电 / 启动）**
- 调用 `SystemClock_Config()`（72 MHz）
- 初始化外设：`MX_GPIO_Init()`, `MX_TIM1_Init()`, `MX_TIM2_Init()`, `MX_TIM4_Init()`, `MX_USART1_UART_Init()`
	- `TIM1`：PWM 输出（PA8），`ARR=999`（范围 0..999），`PSC=71`（与 CubeMX 配置一致）
	- `TIM4`：编码器接口（PB6/PB7），编码器模式 TI1/TI2
	- `TIM2`：基准定时器用于 PID 调度，`PSC=7199`, `ARR=99` -> 10 ms 周期
	- `USART1`：串口（PA9/PA10），`printf` 已重定向到 USART1

**main() 初始化阶段**
- 启动 PWM：`HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1)`
- 启动编码器计数：`HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL)`
- 启动 PID 调度中断：`HAL_TIM_Base_Start_IT(&htim2)` （TIM2 每 10 ms 触发）
- `Motor_Init()`：初始化方向相关 GPIO（当前实现将 PB0/PB1 置为复位/停止）
- 串口接收：工程包含 `usart_cmd.c`（行缓冲接收），但 `main.c` 中注释为“USART receive not needed”，不会自动启用接收；可按需调用 `USART_StartReceive_IT()` 开启
- 初始化 PID：`PID_Init(Kp, Ki, Kd, dt, out_min, out_max)`（当前代码已更新为 `PID_Init(0.6f, 2.0f, 0.02f, 0.01f, 0.0f, 999.0f)`）
- 设置默认目标：`PID_SetTarget(300.0f)`（可在运行时通过串口命令修改）
- 设置电机方向：`Motor_SetDirection(1)`（1 表示前进，映射为 PB0=1, PB1=0）

**主循环（while(1)）**
- 主循环为空，所有控制逻辑在 TIM2 周期中断回调中执行

**定时器回调：TIM2（核心控制环）**
在 `HAL_TIM_PeriodElapsedCallback()` 中（当 `htim->Instance == TIM2` 时）：
- 读取编码器计数：`cnt = __HAL_TIM_GET_COUNTER(&htim4)`，计算 `delta = (int16_t)(cnt - last_cnt)` 并更新 `last_cnt`（处理回绕）
- 计算瞬时 RPM：
	- `dt = 0.01f`（10 ms）
	- `rpm = (delta / ENCODER_PULSES_PER_REV) * (60.0f / dt)`
- 计算控制量：`pwm = PID_Update(rpm)`（`pid.c` 返回 CCR 单位的输出，工程将输出限定在 0..999）
- 死区补偿：若目标 > 0 且 pwm 在 (0, MOTOR_DEADZONE)，将 pwm 提升到 `MOTOR_DEADZONE`（目前 `MOTOR_DEADZONE = 30.0f`）
- 限幅并写入 CCR：`__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, (uint32_t)pwm)`
- 串口输出（用于 vofa）：每 10 次中断（约 100 ms）打印一行 CSV，目前格式为 `target_rpm,current_rpm`（实现：`printf("%.1f,%.1f\r\n", PID_GetTarget(), rpm);`）

**模块 / 函数对应**
- `Core/Src/pid.c`：
	- `PID_Init(Kp,Ki,Kd,dt,out_min,out_max)`：初始化 PID 参数与状态（实现为增量式 PID，并包含积分饱和保护、测量低通滤波、输出斜率限制）
	- `PID_SetTarget(rpm)`：设置目标转速
	- `PID_Update(measured_rpm)`：主控计算，返回控制输出（CCR 值范围 0..999）
	- `PID_GetTarget()`：读取当前目标

- `Core/Src/motor.c`：
	- `Motor_Init()`：设置方向 GPIO 初始态（PB0/PB1 复位）
	- `Motor_SetPWM(compare)`：写入 `TIM1->CCR1`（函数已裁剪到 0..999）
	- `Motor_GetRPM()`：基于 TIM4 CNT 与上次计数计算 RPM（按 10 ms 采样）
	- `Motor_SetDirection(uint8_t forward)`：控制 PB0/PB1，1=前进，0=反转

- `Core/Src/usart_cmd.c`（可选）：行缓冲串口接收实现，包含 `USART_StartReceive_IT()`、`USART_LineAvailable()`、`USART_GetLine()` 与在 `HAL_UART_RxCpltCallback()` 中累积字节。

**PID 算法要点（代码实现）**
- 形式：增量式 PID（避免直接积分导致的突变）
- 测量滤波：对编码器计算的 RPM 做一阶低通滤波（`MEAS_LPF_ALPHA`）以减少抖动
- 抗积分饱和：在输出达到饱和时根据误差方向停止积分累加
- 输出速率限制：`PID_RATE_LIMIT` 用于限制相邻输出差，减小机械冲击
- 死区补偿与输出范围：将小幅 PWM 上提至 `MOTOR_DEADZONE` 以克服电机静态摩擦，最终输出裁剪在 `out_min..out_max`（代码中为 0..999）

**当前默认参数（代码中）**
- 编码器脉冲数：`ENCODER_PULSES_PER_REV` 在 `Core/Inc/pid.h` 中默认 `20`，请根据实际编码器修改
- PID 初始增益（已写入 `main.c`）：`Kp=0.6f`, `Ki=2.0f`, `Kd=0.02f`, `dt=0.01f`, 输出范围 `0..999`

**串口输出（vofa）**
- 当前实现每 100 ms 输出一行：`<target_rpm>,<current_rpm>`（示例：`300.0,298.3`）
- 若需要包含 PWM 值，可以将 `printf` 修改为 `printf("%.1f,%.1f,%d\r\n", PID_GetTarget(), rpm, (int)pwm);`（`pwm` 需在打印处可用）

**构建与生成 ELF（建议）**
在 Windows PowerShell 上示例构建命令（假设已安装 `cmake`, `ninja`, `arm-none-eabi` 工具链，并且仓库的工具链文件为 `cmake/gcc-arm-none-eabi.cmake`）：

```powershell
mkdir build; cd build;
cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=../cmake/gcc-arm-none-eabi.cmake -DCMAKE_BUILD_TYPE=Debug ..;
cmake --build . --config Debug
```

生成的 ELF/HEx 通常位于 `build/` 下的相应输出目录（视 CMake 配置）。将 ELF 或 HEX 加载到 Proteus MCU 即可仿真。

**调参建议（快速步骤）**
1. 保持默认目标（例如 300 RPM），观察 vofa 上的 `target/current` 曲线。若上升缓慢或响应迟钝，按步增大 `Kp`（例如 +0.2）。
2. 若稳态误差存在且响应不振荡，增大 `Ki`（例如 +0.5）。
3. 若出现振荡或振铃，减小 `Kp` 或增大 `Kd`（例如 +0.01）。
4. 若 PWM 出现突变导致驱动异常，降低 `Ki` 或减小 `PID_RATE_LIMIT`。
5. 每次修改后观察 5–10 秒波形再继续调整。

**注意事项与待确认项**
- 确认编码器实际 PPR（`ENCODER_PULSES_PER_REV`）并在 `Core/Inc/pid.h` 中设置正确值。
- 确认电机驱动与方向/使能管脚（当前方向脚为 PB0/PB1；若硬件不同，请告知以便调整 `Motor_Init()` 与驱动逻辑）。
- 若需要更精细的串口输出或非阻塞高吞吐，请考虑使用 USART DMA 或环形缓冲以替代阻塞 `HAL_UART_Transmit`。

---

以上为基于当前工程代码（已应用的修改）的更新版实现流程文档。如需我将该文档另存为仓库根 README 的一节或把 `printf` 改为包含 PWM 的 CSV 行，请告诉我我将直接修改源码并提交。

